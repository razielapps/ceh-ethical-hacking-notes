Of course. Before we use automated tools, let's understand the raw power we wield by learning to create our own network packets from scratch.

Topic 18: Packet Crafting

Up until now, you have been using tools that send pre-defined packets or analyzing packets generated by other applications. Packet crafting is the next level. It is the process of manually building a network packet, byte by byte, giving you complete control over every single field in the protocol headers. Think of it as being an architect who designs a custom key for a specific lock, rather than just trying all the keys on a keychain.

Why is this a crucial skill for an elite hacker?
- **Evasion**: Automated tools have a signature. Intrusion Detection Systems (IDS) and firewalls are trained to recognize the patterns of tools like Nmap. By crafting your own packets, you can create traffic that doesn't match any known signature, allowing you to slip past these defenses.
- **Protocol Manipulation**: You can create packets that exploit subtle flaws in how a target system implements a network protocol. You can send a packet with invalid flags, strange sequence numbers, or oversized payloads to crash a service or trigger unexpected behavior.
- **Precision**: You need to test a very specific scenario? Maybe you want to send a TCP packet with only the FIN flag set to a specific port to see if it bypasses a firewall rule. A packet crafter lets you do this with surgical precision.
- **Understanding**: The process of building a packet yourself forces you to learn the intricate details of protocols like TCP, IP, and ICMP at a deep level. This knowledge is invaluable for advanced exploit development and forensic analysis.

The primary tool for packet crafting is **Scapy**. Scapy is a powerful Python-based interactive packet manipulation program and library. It can forge or decode packets for a wide variety of protocols, send them on the wire, capture them, and match requests and replies. It can handle tasks ranging from simple pings to complex protocol attacks.

Let's break down the basic Scapy workflow:

1.  **Creating Layers**: A network packet is built in layers, just like the OSI model. In Scapy, you create each layer as an object and then stack them together.
    - `IP_layer = IP(dst="192.168.1.1")` creates an IP packet layer with the destination set.
    - `TCP_layer = TCP(dport=80, flags="S")` creates a TCP layer with the destination port 80 and the SYN flag set.
    - `packet = IP_layer/TCP_layer` stacks the IP layer on top of the TCP layer to create a complete packet.

2.  **Sending and Receiving**:
    - `send(packet)` sends the packet at layer 3 (the IP layer). It handles routing but does not expect a reply.
    - `sendp(packet)` sends the packet at layer 2 (the Ethernet layer). You need to specify the interface.
    - `sr1(packet)` is the most important function. It sends the packet and waits for the first response. This is how you can perform a manual TCP SYN scan.

3.  **Customizing Every Field**: You have control over everything.
    - IP Source: `IP(src="spoofed.ip.addr")`
    - TCP Sequence Number: `TCP(seq=1000000)`
    - TCP Window Size: `TCP(window=0)`
    - Payload: `Raw(load="GET / HTTP/1.1\r\nHost: example.com\r\n\r\n")`

A simple example: Performing a manual TCP SYN Scan with Scapy.
```
#!/usr/bin/env python3
from scapy.all import *

target_ip = "scanme.nmap.org"
target_port = 80

# Craft the IP and TCP layers
ip = IP(dst=target_ip)
tcp = TCP(dport=target_port, flags="S")  # 'S' means SYN flag

# Stack them into a packet
packet = ip/tcp

# Send the packet and wait for a single response
response = sr1(packet, timeout=2, verbose=0)

# Analyze the response
if response is None:
    print(f"Port {target_port}: Filtered (No Response)")
elif response.haslayer(TCP):
    if response.getlayer(TCP).flags == 0x12:  # 0x12 is SYN-ACK (18 in decimal)
        print(f"Port {target_port}: Open")
        # Send a RST to close the connection politely
        rst_packet = ip/TCP(dport=target_port, flags="R")
        send(rst_packet, verbose=0)
    elif response.getlayer(TCP).flags == 0x14:  # 0x14 is RST-ACK (20 in decimal)
        print(f"Port {target_port}: Closed")
else:
    print(f"Port {target_port}: Unknown response")
```

This script does what a scanner does, but you wrote it. You control every aspect. This is the essence of packet crafting.

Glossary for Topic 18:

Packet Crafting: The manual process of creating a network packet by specifying the value of every field in its protocol headers, providing maximum control and potential for evasion.

Scapy: A powerful Python-based interactive packet manipulation program and library used for forging, sending, decoding, and manipulating network packets.

Layer 3 (Network Layer): The layer responsible for packet forwarding including routing through different routers. The IP protocol operates here. The `send()` function works at this layer.

Layer 2 (Data Link Layer): The layer that handles communications between adjacent network nodes. The Ethernet protocol operates here. The `sendp()` function works at this layer.

sr1(): A Scapy function that sends a packet and returns the first answer received. Essential for probe-and-response operations.

Flags: In Scapy, TCP flags are set using single letters: S (SYN), A (ACK), F (FIN), R (RST), P (PSH), U (URG).

Payload: The actual data carried within a packet, after all the protocol headers.

Hands-On Assignment for Topic 18:

Your objective is to install Scapy and perform a basic manual port scan, proving you can interact with the network at a fundamental level.

1.  **Install Scapy**: Open your terminal and install it using pip: `pip3 install scapy`

2.  **Enter the Scapy Interactive Environment**: Type `sudo scapy` in your terminal. You need root privileges to send raw packets. You should see a `>>>` prompt.

3.  **Craft and Send a Simple ICMP Echo Request (Ping)**:
    - At the Scapy prompt, type: `pkt = IP(dst="8.8.8.8")/ICMP()`
    - This creates an IP packet destined for Google's DNS, with an ICMP Echo Request inside.
    - Now, send it and wait for a reply: `reply = sr1(pkt, timeout=2)`
    - If you get a reply, type `reply.show()` to see the detailed response packet. You have just manually performed a ping.

4.  **Perform a Manual SYN Scan on a Single Port**:
    - We will scan port 80 on `scanme.nmap.org`.
    - Craft the packet: `syn_pkt = IP(dst="scanme.nmap.org")/TCP(dport=80, flags="S")`
    - Send it and get the reply: `syn_reply = sr1(syn_pkt, timeout=5)`
    - Analyze the reply:
        - If `syn_reply is None`: The port is filtered (no response).
        - Else, check the TCP flags: `syn_reply[TCP].flags`
        - If the flags are `0x12` (SYN-ACK), the port is open.
        - If the flags are `0x14` (RST-ACK), the port is closed.
    - Based on your result, write down the state of port 80.

5.  **Craft a Packet with a Spoofed IP Address (For Education)**:
    - **Warning: Only do this in your own isolated lab. Sending spoofed packets over the internet can have serious consequences.**
    - In your lab, craft a packet with a fake source IP: `spoofed_pkt = IP(src="192.168.1.99", dst="[YOUR_LAB_TARGET_IP]")/ICMP()`
    - Send it: `send(spoofed_pkt)`
    - If you have a sniffer running on the target, you will see the ping arrive, apparently from `192.168.1.99`.

This assignment gives you a taste of the raw power at your fingertips. You are no longer just a user of tools; you are a creator of traffic. This foundational skill is what allows for true innovation and advanced evasion in penetration testing.

Are you ready to proceed to Topic 19: Port Scanning and Enumeration with Nmap?